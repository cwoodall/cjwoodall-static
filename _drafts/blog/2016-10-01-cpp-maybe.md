---
layout: post
author: Chris Woodall
title: "Error Handling: Implementing an Option&lt;T&gt; Type For Embedded C++"
date: 2016-10-01 18:02
comments: true
categories: blog
#image:
---

I have been learning [Rust][rust] lately, which has been an awesome and
rewarding experience thus far. However, at work, and on many of my embedded side
projects I use `C` and `C++` quite extensively. But error handling ends up being
a major pain point and can make an otherwise rather simple API into a disaster.
This can be especially true if you are committed to avoiding throwing exceptions for various
performance and real-time reliability reasons. This is where Rust's model comes
in as a possibly solution (or at the very least an interesting one): the use of
the `Result<T, E>` types and the `Option<T>` type. For the time being I am going to concentrate on the `Option<T>` type and write about the `Result<T, E>` type in a future post.

The code for this blog post can be found on github as [cpp-option][github]!

<!-- more -->

### So what is this `Option<T>` thing any way?

`Option<T>` represents a value which is either a type `T` (like an `int`, `float`, or `MyFancyClass`) or `Nothing`. It is a pretty simple concept.
This makes and `Option<T>` type very good at representing the class of errors
where either you returned the correct result, *or* you just couldn't finish the
computation for some reason. To some degree this is already represented at C. If
you check for errors by passing or returning a pointer and checking if it is a
null pointer or not, that is a really brittle version of the `Option<T>` type.
It is either some value or `NULL`/`nullptr`. For example, below is an
implementation of divide which performs the computation $$\frac{a}{b}$$ but
returns a nullptr if it fails:

```c++
void divide(int a, int b, int *c) {
  if (b == 0) {
    c == nullptr
  } else {
    *c = a/b;
  }
}

int main(void) {
  int c;
  divide(10, 0, &c);
  if (c != nullptr) {
    printf("I got a %d\n", c);
  } else {
    printf("You divided by 0... the world blew up... Thanks");
  }

  return 0;
}
```
<!-- ** -->

Another option, which is much safer from a memory perspective, is to return an
error or success flag (in this case I will use a `bool` with `true` indicating
success and `false` indicating failure):

```c++
bool divide(int a, int b, int *c) {
  if (b == 0) {
    return false; // oh no...
  } else {
    *c = a/b;
    return true; // success!
  }
}  

int main(void) {
  int c;
  bool ret = divide(10, 0, &c);
  if (ret) {
    printf("I got a %d\n", c);
  } else {
    printf("You divided by 0... the world blew up... Thanks");
  }

  return 0;
}
```
<!-- ** -->

So what is wrong with the above two solutions? _Nothing_. However, they are
syntactically a little burdensome, and you can always just bypass the check and
read the pointer, which may even be pointing at invalid data. Languages like
Rust have an `Option<T>` type ([wiki][wiki-option]), also known as `Maybe` in
Haskell and `Optional` in Swift. This type would allows you to return
"something" or "nothing". So lets see an example of the divide program written
with a yet to be implemented `Option<T>` type.

```c++
Option<int> divide(int a, int b) noexcept {
  if (b == 0) {
    return Nothing();
  } else {
    return Some(a/b);
  }
}

int main(void) {
  auto result = divide(10, 0);
  if (!!result) { // Check that result is not Nothing
    printf("I got a %d\n", result.unwrap());
  } else {
    printf("You divided by 0... the world blew up... Thanks");
  }

  return 0;
}
```

So what are the benefits over the other divide-by-zero safe `divide()`
implementations?

1. No need to return a separate `success` or `error` type. Could be a possible
   optimization.
2. Natural calling semantics where the value being returned is the value you
   wanted to return.
3. No need to allocate an `int` ahead of time and pass it as a pointer, or
   reference.
4. The user can't interact with the returned value without interacting with
   the `Option<T>` datatype. Discipline is still required because we can't
   enforce checking ahead of time, but it is a reminder.

### So how do we implement this?

Before I continue I want to say that this type is planned to be included in
**C++17** as the `std::optional` type ([link][c++17-option]). There is also
an implementation of this type in Boost as `boost::optional`
([link][boost-option]), with some awesome work by Andrzej Krzemie≈Ñski. I
highly recommend using one of these two implementations if they are
available right now, but I am constrained from using C++17 or Boost in the
application I want to use this type on. There are a few other implementations of this type in c++ one is by [Cliff
Biffle](http://cliffle.com/) and presented in his Embedded Template
Library ([github][cbiffle-etl]), which has some interesting code and
concepts for C++ on embedded systems. I also found this other
implementation on github which was also inspired by Rust
([github][simonask]). I used all of these great resources and chose to
develop my own implementation to help sharpen my understanding of C++.

First of all, lets set up some requirements.

#### Requirements

1. Should add minimal overhead over type T.
1. Should have minimal `std` library dependencies.
1. Should be stable and reliable, with as few hacks as possible.
1. Never panics or throws...
1. Should work on POD types, would be nice if it worked on more complicated data
   types with non-trivial constructors and destructors.
1. Doesn't need methods which allow for function chaining or lambdas.


#### Implementation

The full, and evolving, implementation can be found
[here](https://github.com/cwoodall/cpp-option) with examples, and unit
tests.

```c++
/**
 * @brief a tag type to represent creating a nothing Option.
 *
 * This makes the following code possible.
 *
 * @code
 * Option<int> always_nothing() { return Nothing(); }
 * @endcode
 */
struct Nothing {};

/**
 * @brief an Option type similar to std::optional, boost::optional, the Haskell
 *        Maybe monad and the Rust Option type.
 *
 * @code
 * Option<int> divide(int a, int b) {
 *   if (b == 0) {
 *     return Nothing();
 *   } else {
 *     return Some(a / b);
 *   }
 * }
 * @endcode
 */
template <typename T>
class Option {
 public:
  Option() : isSomething_(false) {}

  Option(Nothing nothing) : isSomething_(false) {}

  Option(T something) : isSomething_(true), something_(something) {}

  Option(const Option<T> &other)
      : isSomething_(other.isSomething_), something_(other.something_) {}

  Option<T> &operator=(const Option<T> &other) const {
    something_ = other.something_;
    isSomething_ = other.isSomething_;

    return *this;
  }

  Option(Option &&other)
      : something_(other.something_), isSomething_(other.isSomething_) {}

  /**
   * An explicit conversion to bool, which makes boolean comparisons of the
   * Option type possible
   *
   * @return isSomething_ (true if it is something, false otherwise)
   */
  inline constexpr explicit operator bool(void) const { return isSomething_; }

  /**
   * Get the value stored inside of the Option<T> type
   *
   * @return something_;
   */
  inline constexpr T unwrap(void) const { return something_; }

  /**
   * Get the value stored inside of the Option<T> type or if it is Nothing()
   * then return
   *
   * @return something_;
   */
  inline constexpr T unwrap_or(T or_val) const {
    return (isSomething_) ? something_ : or_val;
  }

 private:
  bool isSomething_;  ///< @brief stores whether Some(T) or Nothing is stored
  T something_;       ///< @brief temporary storage for the something object
};

/**
 * Some() is a little bit of sugar. In C++ you can just return your variable
 * T and it will be sent to the Option<T> constructor, for example:
 *
 * @code
 * Option<int> foo(int bar) {
 *  return bar; // No need to create an Option<int>. Option<int>(a) will be
 *              // constructed on return.
 * }
 * @endcode
 *
 * The Some() function allows for the following to work:
 *
 * @code
 * Option<int> foo(int bar) {
 *   return Some(bar);
 * }
 * @endcode
 *
 * This can be useful for creating an Option<T> inside of a function early
 * and using it with in the function. Both forms should have similar
 * performance, but an analysis of this has not been carried out.
 *
 * @param something to wrap in an Option type
 * @return a wrapped verion of something.
 */
template <typename T>
constexpr Option<T> Some(T something) {
  return Option<T>(something);
}
```
<!-- ** -->

[github]: https://github.com/cwoodall/cpp-option
[rust]: http://rust-lang.org
[wiki-option]: https://en.wikipedia.org/wiki/Option_type
[c++17-option]: http://en.cppreference.com/w/cpp/experimental/optional
[simonask]: https://github.com/simonask/simonask.github.com/blob/master/maybe.markdown
[cbiffle-etl]: https://github.com/cbiffle/etl/blob/master/data/maybe.h
[boost-option]: http://www.boost.org/doc/libs/1_61_0/libs/optional/doc/html/index.html
